import json, sys
import numpy as np
from filterpy.kalman import KalmanFilter
from scipy.linalg import block_diag
from filterpy.common import Q_discrete_white_noise
import matplotlib.pyplot as plt
from filterpy.stats import plot_covariance_ellipse

with open('human_data.txt', 'r') as f:
    raw = f.read()
raw = list(raw)
if raw[-4] == ",":
    raw[-4] = ""

raws = ''.join(raw)
data = json.loads(raws)

for d in data["data_set"]:
    if all(np.abs(x<0.1) for x in d["ground_truth"]):
        print("SHIT")

# for d in data["data_set"]:
#     if all(np.abs(x<0.1) for x in d["ground_truth"]):
#         d["ground_truth"] = ant
#     else:
#      ant = d["ground_truth"]


####################################################
# get all x,y measurments in an array
g_truth = np.array([d["ground_truth"][2]  for d in data["data_set"]])
world = np.array([d["world"][2]  for d in data["data_set"]])
# plt.plot(g_truth, color='green')
# plt.plot(world, color='red')
# plt.show()

#####################################################
R_std = 0.35
Q_std = 0.04

def plot_measurements(xs, ys=None, dt=None, color='k', lw=1, label='Measurements',
                      lines=False, **kwargs):
    """ Helper function to give a consistant way to display
    measurements in the book.
    """
    if ys is None and dt is not None:
        ys = xs
        xs = np.arange(0, len(ys)*dt, dt)

    plt.autoscale(tight=False)
    if lines:
        if ys is not None:
            return plt.plot(xs, ys, color=color, lw=lw, ls='--', label=label, **kwargs)
        else:
            return plt.plot(xs, color=color, lw=lw, ls='--', label=label, **kwargs)
    else:
        if ys is not None:
            return plt.scatter(xs, ys, edgecolor=color, facecolor='none',
                        lw=2, label=label, **kwargs),
        else:
            return plt.scatter(range(len(xs)), xs, edgecolor=color, facecolor='none',
                        lw=2, label=label, **kwargs),



def plot_filter(xs, ys=None, dt=None, c='C0', label='Filter', var=None, **kwargs):
    """ plot result of KF with color `c`, optionally displaying the variance
    of `xs`. Returns the list of lines generated by plt.plot()"""
 
    if ys is None and dt is not None:
        ys = xs
        xs = np.arange(0, len(ys) * dt, dt)
    if ys is None:
        ys = xs
        xs = range(len(ys))

    lines = plt.plot(xs, ys, color=c, label=label, **kwargs)
    if var is None:
        return lines

    var = np.asarray(var)
    std = np.sqrt(var)
    std_top = ys+std
    std_btm = ys-std

    plt.plot(xs, ys+std, linestyle=':', color='k', lw=2)
    plt.plot(xs, ys-std, linestyle=':', color='k', lw=2)
    plt.fill_between(xs, std_btm, std_top, facecolor='yellow', alpha=0.2)

    return lines

#####################################################

def Tracker():
    tracker = KalmanFilter(dim_x=4, dim_z=2)
    dt = 1.   # time step 1 second

    tracker.F = np.array([[1, dt, 0,  0],
                        [0,  1, 0,  0],
                        [0,  0, 1, dt],
                        [0,  0, 0,  1]])

                        
    q = Q_discrete_white_noise(dim=2, dt=dt, var=0.001)
    tracker.Q = block_diag(q, q)

    tracker.H = np.array([[1, 0, 0, 0],
                        [0, 0, 1, 0]])

    tracker.R = np.array([[0.6, 0],
                        [0, 0.6]])

    x0 = data["data_set"][0]["world"][0]
    y0 = data["data_set"][2]["world"][2]
    tracker.x = np.array([[x0, y0, 0, 0]]).T
    tracker.P = np.eye(4) * 50.

    return tracker
###############################################

zs = np.array([[d["world"][0], d["world"][2]]  for d in data["data_set"]])

# run filter
robot_tracker = Tracker()
mu, cov, _, _ = robot_tracker.batch_filter(zs)

for x, P in zip(mu, cov):
    # covariance of x and y
    cov = np.array([[P[0, 0], P[2, 0]], 
                    [P[0, 2], P[2, 2]]])
    mean = (x[0, 0], x[2, 0])
    #print(x[0, 0], x[1, 0], x[2, 0], x[3, 0])
    #print(cov)
    plot_covariance_ellipse(mean, cov=cov, fc='g', std=3, alpha=0.5)
    #plt.pause(0.1)

#plot results
plot_filter(mu[:, 0], mu[:, 2])
plot_measurements(zs[:, 0], zs[:, 1])
plt.legend(loc=2)
plt.xlim(0, 20);
plt.show()



